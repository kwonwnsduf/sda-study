🐳 SDA Day 3 — Dockerfile로 이미지 만들고 컨테이너 실행하기

Docker Day 1, 2에서 docker run으로 이미 만들어진 이미지를 실행해봤다면,
오늘은 Docker의 진짜 핵심인 Dockerfile을 직접 작성해봤다.

오늘의 목표는 단순했다.

“내가 만든 파일을 Docker 이미지 안에 넣고,
컨테이너를 실행하면 그 파일이 출력되게 만들어보자.”

📌 Docker에서 가장 중요한 개념 두 가지

Docker를 이해하려면 이미지(Image) 와 컨테이너(Container) 를 반드시 구분해야 한다.

1️⃣ 이미지(Image)

실행할 준비가 끝난 정적인 결과물

OS, 파일, 설정, 실행 명령이 모두 포함됨

실행 ❌, 수정 ❌

👉 클래스 같은 존재

2️⃣ 컨테이너(Container)

이미지를 실제로 실행한 것

프로세스가 돌고 있음

종료되면 멈춤

👉 객체 같은 존재

📌 오늘 만든 파일 구조
day03/
 ├ Dockerfile
 └ app.txt

app.txt
Hello SDA Day 3

📌 Dockerfile 전체 코드
FROM ubuntu:20.04
RUN apt-get update
COPY app.txt /app/app.txt
CMD ["cat", "/app/app.txt"]


이제 각 줄이 왜 필요한지, 그리고 어떤 흐름으로 동작하는지 하나씩 정리해보자.

1️⃣ FROM — 기반 이미지 지정
FROM ubuntu:20.04


이 이미지는 Ubuntu 20.04 리눅스 환경 위에서 만들어진다

Dockerfile은 항상 FROM으로 시작해야 한다

👉 “이 집은 어떤 땅 위에 지을 건지 정하는 단계”

2️⃣ RUN — 이미지 빌드 중 실행되는 명령
RUN apt-get update


Ubuntu 패키지 목록을 최신 상태로 갱신

이미지를 만들 때(build 시점) 딱 한 번 실행됨

실행 결과는 이미지 안에 저장된다

📌 RUN은 환경 세팅용
(프로그램 설치, 설정 등)

3️⃣ COPY — 로컬 파일을 이미지 안으로 복사
COPY app.txt /app/app.txt


이 줄이 핵심이었다.

로컬에 있는 app.txt 파일을

이미지 안의 /app/app.txt 위치로 복사

중요한 점은:

/app 폴더는 원래 존재하지 않는다

COPY를 하면 자동으로 생성된다

즉,

/
└ app/
    └ app.txt


👉 app.txt도 우리가 만든 파일이고
👉 /app 폴더도 COPY 과정에서 만들어진 것

4️⃣ CMD — 컨테이너 실행 시 실행할 명령
CMD ["cat", "/app/app.txt"]


컨테이너가 시작될 때 실행되는 기본 명령

이미지 빌드 시에는 실행 ❌

docker run 할 때 실행 ⭕

이 명령은 결국 리눅스에서:

cat /app/app.txt


를 실행하는 것과 같다.

📌 배열 형태(["cat", "..."])는
쉘을 거치지 않는 exec form이라 실무에서 권장된다.

📌 이미지 빌드란 무엇인가?
docker build -t sda-day3 .


이 명령은:

Dockerfile을 위에서부터 한 줄씩 읽으면서
실행 가능한 이미지를 만드는 과정

이때:

Ubuntu 환경이 들어오고

패키지 목록이 갱신되고

app.txt 파일이 이미지 안에 들어가고

실행 명령(CMD)이 저장된다

📦 결과물은 이미지
(아직 실행은 안 됨)

📌 컨테이너 실행이란 무엇인가?
docker run sda-day3


이 순간 일어나는 일:

이미지 기반으로 컨테이너 생성

파일 시스템 로드

CMD 실행 (cat /app/app.txt)

출력 후 종료

출력 결과:

Hello SDA Day 3


📌 실행할 프로세스가 끝나면
컨테이너도 바로 종료된다.

📌 왜 이런 과정을 거칠까?

이 예제 자체는 굉장히 단순하다.
로컬에서 cat app.txt 하면 끝이다.

하지만 이걸 Docker로 한 이유는 단 하나다.

“어디서 실행하든, 항상 같은 환경과 같은 결과를 만들기 위해”
