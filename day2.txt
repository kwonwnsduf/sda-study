DB는 왜 필요한가?
처음에는
“그냥 파일로 저장하면 안 되나?”라는 생각이 들었는데,
조금만 생각해보면 문제가 많다.

동시에 여러 요청이 오면 데이터가 꼬일 수 있고

검색/정렬이 느리며

중복 데이터가 계속 쌓이고

보안이나 권한 관리도 어렵다

그래서 서버에서는 상태를 직접 들고 있지 않고,
데이터를 DB에 맡긴다는 개념이 중요하다는 걸 이해했다.

서버는 stateless,
상태는 DB가 관리한다.

관계형 DB(RDB)의 기본 구조
관계형 DB는 기본적으로 테이블 구조를 가진다.

행(Row) → 데이터 한 줄

열(Column) → 속성

그리고 이 테이블에서 가장 중요한 개념이
Primary Key(PK) 와 Foreign Key(FK) 다.

id BIGINT PRIMARY KEY 이해하기
_id BIGINT PRIMARY KEY
이 한 줄은
“이 테이블에서 각 데이터를 유일하게 구분하는 기준”이라는 의미다.

id : 식별자 역할

BIGINT : 큰 정수 타입 (보통 ID용)

PRIMARY KEY

중복 불가

NULL 불가

자동으로 인덱스 생성

즉,
PK는 테이블에서 각 행의 주민등록번호 같은 존재다.

member_id BIGINT REFERENCES members(id)
member_id BIGINT REFERENCES members(id)
이 부분이 관계형 DB의 핵심이다.

이 의미는 단순히 숫자를 저장하는 게 아니라,

“이 컬럼은 members 테이블의 id만 참조할 수 있다”

라는 뜻이다.

이렇게 하면 DB가 직접 다음을 보장해준다.

존재하지 않는 회원 ID 삽입 ❌

테이블 간 관계 무결성 유지

이게 나중에 JPA의
@ManyToOne, @JoinColumn으로 그대로 이어진다는 점이 인상 깊었다.

VARCHAR(100)은 무슨 뜻일까?
처음엔 그냥 “문자열”이라고만 생각했는데,
정확히는 최대 100자까지 저장 가능한 가변 길이 문자열이다.

실제 길이만큼만 공간 사용

이메일, 이름, 상태값 등에 주로 사용

실무에서는 보통

email → VARCHAR(100~255)

password(해시) → VARCHAR(255)

상태값 → VARCHAR(20)

처럼 사용된다는 것도 알게 됐다.

SQL의 기본: CRUD
SQL에서 가장 중요한 건 CRUD다.

CREATE → INSERT

READ → SELECT

UPDATE → UPDATE

DELETE → DELETE

이 중에서도 오늘은 SELECT를 가장 많이 다뤘다.

SELECT COUNT(*) FROM members;
이 SQL은
members 테이블에 데이터가 몇 개 있는지를 세는 쿼리다.

여기서 중요한 점은:

COUNT(*)는 행(row) 개수

NULL 여부와 상관없이 전부 센다

회원 수, 데이터 개수, 페이징 처리 등
실무에서 정말 많이 쓰일 패턴이라는 걸 알게 됐다.

ORDER BY id DESC 정렬 조회
SELECT * FROM members ORDER BY id DESC;
이 문장은 사실상

“최신 데이터부터 조회해라”

라는 의미다.

보통 id는 자동 증가 값이기 때문에
숫자가 클수록 최근 데이터가 된다.

그래서 최신 회원, 최근 주문,최근 글을 가져올 때 거의 항상 쓰이는 패턴이라는 점을 배웠다.

오늘 정리하면서 느낀 점
DB는 단순 저장소가 아니라 무결성과 관계를 보장하는 시스템

PK와 FK 개념이 모든 설계의 출발점

SQL은 문법보다 의미를 이해하는 게 중요

오늘 배운 내용이
나중에 Spring + JPA로 넘어갔을 때
“왜 이렇게 설계했는지”를 이해하는 기반이 될 것 같다.
